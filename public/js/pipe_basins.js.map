{"version":3,"names":[],"mappings":"","sources":["pipe_basins.js"],"sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\n(function (global){\n'use strict';\n\nvar $ = (typeof window !== \"undefined\" ? window['jQuery'] : typeof global !== \"undefined\" ? global['jQuery'] : null);\n\n$('.success-panel, .error-panel').addClass('alert fade in');\n$().alert();\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{}],2:[function(require,module,exports){\n(function (global){\n; var __browserify_shim_require__=require;(function browserifyShim(module, define, require) {\n\"use strict\";\n\n/*\r\n * Flot plugin to order bars side by side.\r\n * \r\n * Released under the MIT license by Benjamin BUFFET, 20-Sep-2010.\r\n *\r\n * This plugin is an alpha version.\r\n *\r\n * To activate the plugin you must specify the parameter \"order\" for the specific serie :\r\n *\r\n *  $.plot($(\"#placeholder\"), [{ data: [ ... ], bars :{ order = null or integer }])\r\n *\r\n * If 2 series have the same order param, they are ordered by the position in the array;\r\n *\r\n * The plugin adjust the point by adding a value depanding of the barwidth\r\n * Exemple for 3 series (barwidth : 0.1) :\r\n *\r\n *          first bar décalage : -0.15\r\n *          second bar décalage : -0.05\r\n *          third bar décalage : 0.05\r\n *\r\n */\n\n(function ($) {\n    function init(plot) {\n        var orderedBarSeries;\n        var nbOfBarsToOrder;\n        var borderWidth;\n        var borderWidthInXabsWidth;\n        var pixelInXWidthEquivalent = 1;\n        var isHorizontal = false;\n\n        /*\r\n         * This method add shift to x values\r\n         */\n        function reOrderBars(plot, serie, datapoints) {\n            var shiftedPoints = null;\n\n            if (serieNeedToBeReordered(serie)) {\n                checkIfGraphIsHorizontal(serie);\n                calculPixel2XWidthConvert(plot);\n                retrieveBarSeries(plot);\n                calculBorderAndBarWidth(serie);\n\n                if (nbOfBarsToOrder >= 2) {\n                    var position = findPosition(serie);\n                    var decallage = 0;\n\n                    var centerBarShift = calculCenterBarShift();\n\n                    if (isBarAtLeftOfCenter(position)) {\n                        decallage = -1 * sumWidth(orderedBarSeries, position - 1, Math.floor(nbOfBarsToOrder / 2) - 1) - centerBarShift;\n                    } else {\n                        decallage = sumWidth(orderedBarSeries, Math.ceil(nbOfBarsToOrder / 2), position - 2) + centerBarShift + borderWidthInXabsWidth * 2;\n                    }\n\n                    shiftedPoints = shiftPoints(datapoints, serie, decallage);\n                    datapoints.points = shiftedPoints;\n                }\n            }\n            return shiftedPoints;\n        }\n\n        function serieNeedToBeReordered(serie) {\n            return serie.bars != null && serie.bars.show && serie.bars.order != null;\n        }\n\n        function calculPixel2XWidthConvert(plot) {\n            var gridDimSize = isHorizontal ? plot.getPlaceholder().innerHeight() : plot.getPlaceholder().innerWidth();\n            var minMaxValues = isHorizontal ? getAxeMinMaxValues(plot.getData(), 1) : getAxeMinMaxValues(plot.getData(), 0);\n            var AxeSize = minMaxValues[1] - minMaxValues[0];\n            pixelInXWidthEquivalent = AxeSize / gridDimSize;\n        }\n\n        function getAxeMinMaxValues(series, AxeIdx) {\n            var minMaxValues = new Array();\n            for (var i = 0; i < series.length; i++) {\n                minMaxValues[0] = series[i].data[0][AxeIdx];\n                minMaxValues[1] = series[i].data[series[i].data.length - 1][AxeIdx];\n            }\n            return minMaxValues;\n        }\n\n        function retrieveBarSeries(plot) {\n            orderedBarSeries = findOthersBarsToReOrders(plot.getData());\n            nbOfBarsToOrder = orderedBarSeries.length;\n        }\n\n        function findOthersBarsToReOrders(series) {\n            var retSeries = new Array();\n\n            for (var i = 0; i < series.length; i++) {\n                if (series[i].bars.order != null && series[i].bars.show) {\n                    retSeries.push(series[i]);\n                }\n            }\n\n            return retSeries.sort(sortByOrder);\n        }\n\n        function sortByOrder(serie1, serie2) {\n            var x = serie1.bars.order;\n            var y = serie2.bars.order;\n            return x < y ? -1 : x > y ? 1 : 0;\n        }\n\n        function calculBorderAndBarWidth(serie) {\n            borderWidth = serie.bars.lineWidth ? serie.bars.lineWidth : 2;\n            borderWidthInXabsWidth = borderWidth * pixelInXWidthEquivalent;\n        }\n\n        function checkIfGraphIsHorizontal(serie) {\n            if (serie.bars.horizontal) {\n                isHorizontal = true;\n            }\n        }\n\n        function findPosition(serie) {\n            var pos = 0;\n            for (var i = 0; i < orderedBarSeries.length; ++i) {\n                if (serie == orderedBarSeries[i]) {\n                    pos = i;\n                    break;\n                }\n            }\n\n            return pos + 1;\n        }\n\n        function calculCenterBarShift() {\n            var width = 0;\n\n            if (nbOfBarsToOrder % 2 != 0) width = orderedBarSeries[Math.ceil(nbOfBarsToOrder / 2)].bars.barWidth / 2;\n\n            return width;\n        }\n\n        function isBarAtLeftOfCenter(position) {\n            return position <= Math.ceil(nbOfBarsToOrder / 2);\n        }\n\n        function sumWidth(series, start, end) {\n            var totalWidth = 0;\n\n            for (var i = start; i <= end; i++) {\n                totalWidth += series[i].bars.barWidth + borderWidthInXabsWidth * 2;\n            }\n\n            return totalWidth;\n        }\n\n        function shiftPoints(datapoints, serie, dx) {\n            var ps = datapoints.pointsize;\n            var points = datapoints.points;\n            var j = 0;\n            for (var i = isHorizontal ? 1 : 0; i < points.length; i += ps) {\n                points[i] += dx;\n                //Adding the new x value in the serie to be abble to display the right tooltip value,\n                //using the index 3 to not overide the third index.\n                serie.data[j][3] = points[i];\n                j++;\n            }\n\n            return points;\n        }\n\n        plot.hooks.processDatapoints.push(reOrderBars);\n    }\n\n    var options = {\n        series: {\n            bars: { order: null } // or number/string\n        }\n    };\n\n    $.plot.plugins.push({\n        init: init,\n        options: options,\n        name: \"orderBars\",\n        version: \"0.2\"\n    });\n})(jQuery);\n\n}).call(global, module, undefined, undefined);\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{}],3:[function(require,module,exports){\n\"use strict\";\n\nmodule.exports = function (array) {\n    var a = array.concat();\n    for (var i = 0; i < a.length; ++i) {\n        for (var j = i + 1; j < a.length; ++j) {\n            if (a[i] === a[j]) a.splice(j--, 1);\n        }\n    }\n\n    return a;\n};\n\n},{}],4:[function(require,module,exports){\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n// Create custom throttled events that only occur once per animation frame\n// Code from https://developer.mozilla.org/en-US/docs/Web/Events/resize\nvar throttle = function throttle(type, name, obj) {\n    obj = obj || window;\n    var running = false;\n    var func = function func() {\n        if (running) return;\n        running = true;\n        requestAnimationFrame(function () {\n            obj.dispatchEvent(new CustomEvent(name));\n            running = false;\n        });\n    };\n    obj.addEventListener(type, func);\n};\n\nexports.default = throttle;\n\n},{}],5:[function(require,module,exports){\n(function (global){\n'use strict';\n\nrequire('./app');\n\nvar _jquery = (typeof window !== \"undefined\" ? window['jQuery'] : typeof global !== \"undefined\" ? global['jQuery'] : null);\n\nvar _jquery2 = _interopRequireDefault(_jquery);\n\nrequire('jquery.flot.orderBars');\n\nvar _throttle = require('./modules/throttle');\n\nvar _throttle2 = _interopRequireDefault(_throttle);\n\nvar _array_unique = require('./modules/array_unique');\n\nvar _array_unique2 = _interopRequireDefault(_array_unique);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n// Query the DOM elements we are going to need\n// Allows for multi-series bar graph\nvar $plot = document.getElementById('plot');\nvar $legendContainer = document.getElementById('plot-legend');\nvar $plotData = document.getElementById('plot-data');\n\n// Obtain the plot data from the DOM\nvar data = JSON.parse($plotData.innerHTML);\n\n// Map the data to the format flot requires\nvar series = data.map(function (d) {\n    return {\n        bars: { order: true }, // Enable the orderBars plugin\n        label: d.basin,\n        data: d.occurrences\n    };\n});\n\n// Utility functions for finding min and max\nvar flatMap = function flatMap(arr, fn) {\n    return Array.prototype.concat.apply([], arr.map(fn));\n};\nvar min = function min(arr) {\n    return Math.min.apply(null, arr);\n};\nvar max = function max(arr) {\n    return Math.max.apply(null, arr);\n};\n\n// Concat all datapoints together and then map to the x coordinate\nvar years = flatMap(data, function (d) {\n    return d.occurrences;\n}).map(function (point) {\n    return point[0];\n});\n\nvar minyear = min(years);\nvar maxyear = max(years);\n\n// Flot's options object\nvar options = {\n    series: {\n        bars: { show: true }\n    },\n    bars: {\n        // 0.3 is the space between bars from different datapoints\n        barWidth: (1 - 0.3) / series.length\n    },\n    legend: {\n        // Horizontal legend\n        noColumns: 0,\n        container: $legendContainer\n    },\n    xaxis: {\n        min: minyear - 1,\n        max: maxyear + 1,\n        ticks: (0, _array_unique2.default)(years)\n    }\n};\n\n// Wrap plot action in a function\nvar plot = function plot() {\n    _jquery2.default.plot($plot, series, options);\n};\n\n// Create custom throttled resize event\n(0, _throttle2.default)('resize', 'tResize');\n\n// plot normally\nplot();\n// re-plot on resize\n// without this the plot stays at the same sime when the window is resized\n// There is no need to recalculate the width as it is obtained from the\n// container element, which should escale on a responsive fashion\nwindow.addEventListener('tResize', plot);\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{\"./app\":1,\"./modules/array_unique\":3,\"./modules/throttle\":4,\"jquery.flot.orderBars\":2}]},{},[5]);\n"],"file":"pipe_basins.js","sourceRoot":"/source/"}